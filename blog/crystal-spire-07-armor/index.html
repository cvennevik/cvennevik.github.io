<!DOCTYPE html>
<html lang="en">
    <head>
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="color-scheme" content="dark light">
        <title>Crystal Spire #7: Armor - Cecilie Vennevik</title>
        <link rel="icon" type="image/jpg" href="/img/logo-32px.jpg" sizes="32x32">
        <link rel="icon" type="image/jpg" href="/img/logo-48px.jpg" sizes="48x48">
        <link rel="icon" type="image/jpg" href="/img/logo-64px.jpg" sizes="64x64">
        <meta name="author" content="Cecilie Vennevik">
        <link rel="alternate" title="Cecilie Vennevik's blog" href="/blog/rss.xml" type="application/rss+xml">
        <link rel="alternate" title="Cecilie Vennevik's blog" href="/blog/atom.xml" type="application/atom+xml">
        <style>
            *,
*::after,
*::before {
	box-sizing: border-box;
}

:root {
	--codeblock-color: #eee;
	--codeblock-background-color: #2b2b2b;
	--home-link-focus-color: #89cff0;

	--background-color: #f0f9fd;
	--foreground-color: rgba(255, 255, 255, 30%);
	--border-color: rgba(0, 0, 0, 10%);
	--text-color: #212;
	--code-background-color: rgba(0, 0, 0, 10%);
	--link-color: #086391;
	--link-focus-color: #89cff0;
	--header-background-color: #89cff0;
	--header-background-border-color: #086391;
	--header-link-color: #086391;
	--header-link-focus-color: #f0f9fd;
}

@media (prefers-color-scheme: dark) {
	:root {
		--background-color: #222;
		--foreground-color: #444;
		--border-color: rgba(255, 255, 255, 10%);
		--text-color: #fff;
		--code-background-color: #444;
		--link-color: #89cff0;
		--link-focus-color: #b8e2f6;
		--header-background-color: #086391;
		--header-background-border-color: #034c70;
		--header-link-color: #89cff0;
		--header-link-focus-color: #f0f9fd;
	}
}

html {
	background-color: var(--background-color);
	color: var(--text-color);
	font-family: 'Helvetica Neue', 'Arial Nova', Helvetica, Arial, sans-serif;
	height: 100%;
	line-height: 1.5;
}

body {
	margin: 0;
	padding: 0;
}

body > header {
	--link-color: var(--header-link-color);
	--link-focus-color: var(--header-link-focus-color);
	background-color: var(--header-background-color);
	border-bottom: .25rem solid var(--header-background-border-color);
}

.navbar {
	align-items: center;
	box-sizing: content-box;
	display: flex;
	gap: 1rem;
	margin: auto;
	max-width: 50rem;
	min-height: 3rem;
	padding: .5rem 1rem;
}

.navbar img {
	border-radius: 100%;
	display: inline-block;
	height: 2rem;
	width: 2rem;
}

.navbar nav {
	flex-grow: 1;
}

.crumbs {
	align-items: center;
	display: flex;
	gap: .5rem;
	list-style: none;
	margin: 0;
	padding: 0;
}

.crumbs li {
	display: flex;
	gap: .5rem;
}

main {
	margin: 0 auto;
	max-width: 50rem;
	padding: 1rem;
}

h1 { font-size: 2.5rem; }
h2 { font-size: 2rem; }
h3 { font-size: 1.75rem; }
h4 { font-size: 1.5rem; }
h5 { font-size: 1.3rem; }
h6 { font-size: 1.2rem; }

h1, h2, h3, h4, h5, h6 {
	font-weight: bold;
	line-height: 1.1;
	margin-block-start: 1em;
	margin-block-end: 0;
}

h1 {
	margin-block-start: 0;
}

a {
	color: var(--link-color);
	transition: color .1s;
}

a:focus,
a:hover {
	color: var(--link-focus-color);
}

blockquote {
	border-left: .3rem solid var(--border-color);
	margin: 1rem 0;
	padding: 0 1rem;
}

:not(pre) > code {
	background-color: var(--code-background-color);
}

pre {
	background-color: var(--codeblock-background-color);
	border-radius: 0.5em;
	color: var(--codeblock-color);
	font-family: ui-monospace, 'Cascadia Code', 'Source Code Pro', Menlo, Consolas, 'DejaVu Sans Mono', monospace;
	hyphens: none;
	line-height: 1.4;
	padding: 1em;
	overflow: auto;
	tab-size: 4;
	white-space: pre-wrap;
}

img {
	max-width: 100%;
}

figure {
	display: flex;
	flex-direction: column;
	justify-content: center;
	margin: 1.3rem 0;
}

figure img {
	border: .3rem solid var(--border-color);
	border-radius: .3rem;
}

figcaption {
	font-style: italic;
	margin-top: .5em;
	text-align: center;
}

        </style>
        <script>
            // <input-persist> observes all contained input elements with a [data-persist-key] attribute.
// When the user changes the value of an input element, it saves that value to local storage.
// The [data-persist-key] attribute specifies the storage key.
// When an input element first loads - or is placed - inside <input-parsist>, its value is set to the stored value.
//
// <input-persist> supports the following elements:
// - <input type="checkbox">
// - <input type="radio">
customElements.define(
  "input-persist",
  class extends HTMLElement {
    connectedCallback() {
      const observer = new MutationObserver((mutations) => {
        mutations.forEach((mutation) => {
          mutation.removedNodes.forEach((node) => {
            node.removeEventListener("input", this);
          });
          mutation.addedNodes.forEach((node) => {
            if (node.nodeName == "INPUT") {
              node.addEventListener("input", this);
              const persistKey = node.dataset.persistKey;
              if (!persistKey) return;

              const savedValue = localStorage.getItem(persistKey);
              if (savedValue) {
                switch (node.type) {
                  case "checkbox":
                  case "radio":
                    node.checked = savedValue === "checked";
                    break;
                  default:
                    console.warn(
                      `input-persist: cannot persist unsupported element <input type=${node.type}>.`,
                      node
                    );
                    break;
                }
              }
            }
          });
        });
      });
      observer.observe(this, { childList: true, subtree: true });
    }

    handleEvent(event) {
      const persistKey = event.target.dataset.persistKey;
      if (!persistKey) return;

      switch (event.target.type) {
        case "checkbox":
          localStorage.setItem(
            persistKey,
            event.target.checked ? "checked" : "unchecked"
          );
          break;
        case "radio":
          const radioName = event.target.getAttribute("name");
          this.querySelectorAll(`input[name=${radioName}]`).forEach((radio) => {
            if (radio.dataset.persistKey) {
              localStorage.setItem(
                radio.dataset.persistKey,
                radio === event.target ? "checked" : "unchecked"
              );
            }
          });
          break;
        default:
          console.warn(
            `input-persist: cannot persist unsupported element <input type=${event.target.type}>.`,
            event.target
          );
          break;
      }
    }
  }
);
        </script>
    </head>
    <body>
        <header>
            <div class="navbar">
                
                <img src="/img/logo-250px.jpg" alt="Seal-in-a-glass logo">
                <nav aria-labelledby="navbar-label">
                    <span id="navbar-label">You are here.</span>
                    <ol class="crumbs">
                        
<li>
    <a href="/">Home</a>
    <span aria-hidden="true">/</span>
</li>
<li>
    <a href="/blog/">Blog</a>
    <span aria-hidden="true">/</span>
</li>
<li>Post</li>

                    </ol>
                </nav>
                
            </div>
        </header>
        <main>
            
<style>
    h1 {
        margin-block-start: 0;
    }
</style>
<article>
    <h1>Crystal Spire #7: Armor</h1>
    <i>August 24, 2024</i>
    <p>We're back! With an updated series title! Nearly two weeks since the last post now. Hard to find time to write as a working parent.</p>
<p>Currently, our page is a bit of dynamically rendered HTML. Some of the content is based on the query string, others are hard-coded. The next logical step is making a little bit less of it hard-coded. Adding armor seems like a nice way to warm up.</p>
<p>Hmm. First I want to do a little refactoring. I want to extract our JavaScript to a separate file. It's not strictly necessary, and has a couple of cons (like adding another round-trip time on first page load, and not being able to throw our whole project around as a single HTML file), but it has several pros that I want right now:</p>
<ul>
<li>We can look at all the already-getting-quite-hairy parsing logic and templating without looking at all the HTML wrapping it.</li>
<li>We can comfortably remove one level of indentation.</li>
<li>Down the line, we want to be able to <em>test</em> the code, and having a separate file we can import the code from will help us out a lot.</li>
</ul>
<p>So, creating a file... What's the default name people give JavaScript files now, anyway? script.js? main.js? index.js? index.js lines up neatly with index.html in the file explorer, so let's go with that.</p>
<p>Wow, I've forgotten how to link to external JavaScript files from HTML, it's been so long since I set up a new project without a build system. Quick jump to the <a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/script">MDN <code>&lt;script&gt;</code> element page</a>...</p>
<p>Whew, there's quite a few attributes to choose from nowadays! But after copying and pasting our JavaScript to the new file, it looks like we don't need any of the <code>type</code> or <code>async</code> or <code>defer</code> stuff, all we need to write is:</p>
<pre><code class="language-html">&lt;script src=&quot;index.js&quot;&gt;&lt;/script&gt;
</code></pre>
<p>I'm wondering if we should also add <code>type=&quot;module&quot;</code>. JavaScript modules are the modern way of structuring code, but a quick scan of <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Modules">the JavaScript modules page</a> reminds me that, yeah, it only really matters for exporting and importing code, and I'm not planning on splitting index.js into multiple files anytime soon. Let's keep it dead simple and omit it.</p>
<p>Commit: &quot;Extract JavaScript to index.js&quot;.</p>
<p>Back to armor. Let's start by sketching it up in hardcoded HTML:</p>
<pre><code class="language-html">&lt;p&gt;Armor: 5&lt;/p&gt;
</code></pre>
<p>Yeah, that's simple. And when there is no armor, we want to omit that paragraph entirely. Let's make it dynamic by adding a query parameter for &quot;armor&quot;:</p>
<pre><code class="language-js">let armor = queryParams.get('armor');
</code></pre>
<p>We're not assigning a fallback value here if &quot;armor&quot; is missing, because a <code>null</code> value is going to work fine the way we'll use it:</p>
<pre><code class="language-js">${armor ? `&lt;p&gt;Armor: ${armor}&lt;/p&gt;` : ''}
</code></pre>
<p>JavaScript type coercion is great, actually. If <code>armor</code> is any kind of <a href="https://developer.mozilla.org/en-US/docs/Glossary/Falsy">falsy value</a>, like <code>null</code>, <code>undefined</code>, or <code>0</code>, it evaluates to <code>false</code> and we render an empty string. If it has a <a href="https://developer.mozilla.org/en-US/docs/Glossary/Truthy">truthy value</a> - in other words, if we have any kind of armor - we render it in a paragraph. This is really handy and terse! But we need to see that it works, first. Let's add <code>&amp;armor=5</code> to our &quot;Play Defend&quot; query string:</p>
<pre><code class="language-html">&lt;a href=&quot;?maxhp=80&amp;maxenergy=3&amp;relics=Burning%20Blood&amp;hp=80&amp;armor=5&amp;energy=2&amp;hand=Bash,Defend,Defend,Strike&amp;draw=Defend,Strike,Strike,Strike,Strike&amp;discard=Defend&quot;&gt;
    Play Defend
&lt;/a&gt;
</code></pre>
<p>Wow, these URLs are getting terribly long. But it works! We get &quot;Armor: 5&quot; on that page, and nothing on the others. Commit: &quot;Render armor based on query parameter&quot;</p>
<p>Ah, my hour is already up. Small progress, but progress nonetheless.</p>
<hr>
<p><em><a href="https://codeberg.org/cvennevik/crystal-spire/src/commit/bc434acde371050735ad5e59736efdcb6ca71861/">Last commit: Render armor based on query parameter</a></em></p>

</article>

        </main>
    </body>
</html>