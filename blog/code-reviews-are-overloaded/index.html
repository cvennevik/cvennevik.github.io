<!DOCTYPE html>
<html lang="en" class="js-disabled">
    <head>
        <script>document.documentElement.classList.remove('js-disabled');</script>
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <title>Code reviews are overloaded - Cecilie Vennevik</title>
        <link rel="icon" type="image/jpg" href="/img/logo-32px.jpg" sizes="32x32">
        <link rel="icon" type="image/jpg" href="/img/logo-48px.jpg" sizes="48x48">
        <link rel="icon" type="image/jpg" href="/img/logo-64px.jpg" sizes="64x64">
        <meta name="author" content="Cecilie Vennevik">
        <link rel="alternate" title="Cecilie Vennevik's blog" href="/blog/rss.xml" type="application/rss+xml">
        <link rel="alternate" title="Cecilie Vennevik's blog" href="/blog/atom.xml" type="application/atom+xml">
        <style>
            *,
*::after,
*::before {
	box-sizing: border-box;
}

:root {
	--codeblock-color: #eee;
	--codeblock-background-color: #2b2b2b;
	--home-link-focus-color: #89cff0;

	--background-color: #f0f9fd;
	--foreground-color: rgba(255, 255, 255, 30%);
	--border-color: rgba(0, 0, 0, 10%);
	--text-color: #212;
	--code-background-color: rgba(0, 0, 0, 10%);
	--link-color: #086391;
	--link-focus-color: #89cff0;
}

@media (prefers-color-scheme: dark) {
	:root {
		--background-color: #222;
		--foreground-color: #444;
		--border-color: rgba(255, 255, 255, 10%);
		--text-color: #fff;
		--code-background-color: #444;
		--link-color: #89cff0;
		--link-focus-color: #b8e2f6;
	}
}

:root:has(#light-color-scheme:checked) {
	--background-color: #f0f9fd;
	--foreground-color: rgba(255, 255, 255, 30%);
	--border-color: rgba(0, 0, 0, 10%);
	--text-color: #212;
	--code-background-color: rgba(0, 0, 0, 10%);
	--link-color: #086391;
	--link-focus-color: #89cff0;
}

:root:has(#dark-color-scheme:checked) {
	--background-color: #222;
	--foreground-color: #444;
	--border-color: rgba(255, 255, 255, 10%);
	--text-color: #fff;
	--code-background-color: #444;
	--link-color: #89cff0;
	--link-focus-color: #b8e2f6;
}

html {
	background-color: var(--background-color);
	color: var(--text-color);
	font-family: 'Helvetica Neue', 'Arial Nova', Helvetica, Arial, sans-serif;
	height: 100%;
	line-height: 1.5;
}

body {
	margin: 0 auto;
	max-width: 50rem;
	padding: 1rem;
	padding-bottom: 2rem;
}

h1,
h2,
h3,
h4,
h5,
h6 {
	font-weight: bold;
	line-height: 1.1;
	margin-block-start: 1em;
	margin-block-end: 0;
}

h1 {
	font-size: 2.5rem;
}

h2 {
	font-size: 2rem;
}

h3 {
	font-size: 1.75rem;
}

h4 {
	font-size: 1.5rem;
}

h5 {
	font-size: 1.3rem;
}

h6 {
	font-size: 1.2rem;
}

a {
	color: var(--link-color);
	transition: color .1s;
}

a:focus,
a:hover {
	color: var(--link-focus-color);
}

blockquote {
	border-left: .3rem solid var(--border-color);
	margin: 1rem 0;
	padding: 0 1rem;
}

:not(pre)>code {
	background-color: var(--code-background-color);
}

pre {
	background-color: var(--codeblock-background-color);
	border-radius: 0.5em;
	color: var(--codeblock-color);
	font-family: ui-monospace, 'Cascadia Code', 'Source Code Pro', Menlo, Consolas, 'DejaVu Sans Mono', monospace;
	hyphens: none;
	line-height: 1.4;
	padding: 1em;
	overflow: auto;
	tab-size: 4;
	white-space: pre-wrap;
}

img {
	max-width: 100%;
}

figure {
	display: flex;
	flex-direction: column;
	justify-content: center;
	margin: 1.3rem 0;
}

figure img {
	border: .3rem solid var(--border-color);
	border-radius: .3rem;
}

figcaption {
	font-style: italic;
	margin-top: .5em;
	text-align: center;
}

.js-disabled .js-only {
	display: none;
}
        </style>
        <script>
            // <input-persist> observes all contained input elements with a [data-persist-key] attribute.
// When the user changes the value of an input element, it saves that value to local storage.
// The [data-persist-key] attribute specifies the storage key.
// When an input element first loads - or is placed - inside <input-parsist>, its value is set to the stored value.
//
// <input-persist> supports the following elements:
// - <input type="checkbox">
// - <input type="radio">
customElements.define(
  "input-persist",
  class extends HTMLElement {
    connectedCallback() {
      const observer = new MutationObserver((mutations) => {
        mutations.forEach((mutation) => {
          mutation.removedNodes.forEach((node) => {
            node.removeEventListener("input", this);
          });
          mutation.addedNodes.forEach((node) => {
            if (node.nodeName == "INPUT") {
              node.addEventListener("input", this);
              const persistKey = node.dataset.persistKey;
              if (!persistKey) return;

              const savedValue = localStorage.getItem(persistKey);
              if (savedValue) {
                switch (node.type) {
                  case "checkbox":
                  case "radio":
                    node.checked = savedValue === "checked";
                    break;
                  default:
                    console.warn(
                      `input-persist: cannot persist unsupported element <input type=${node.type}>.`,
                      node
                    );
                    break;
                }
              }
            }
          });
        });
      });
      observer.observe(this, { childList: true, subtree: true });
    }

    handleEvent(event) {
      const persistKey = event.target.dataset.persistKey;
      if (!persistKey) return;

      switch (event.target.type) {
        case "checkbox":
          localStorage.setItem(
            persistKey,
            event.target.checked ? "checked" : "unchecked"
          );
          break;
        case "radio":
          const radioName = event.target.getAttribute("name");
          this.querySelectorAll(`input[name=${radioName}]`).forEach((radio) => {
            if (radio.dataset.persistKey) {
              localStorage.setItem(
                radio.dataset.persistKey,
                radio === event.target ? "checked" : "unchecked"
              );
            }
          });
          break;
        default:
          console.warn(
            `input-persist: cannot persist unsupported element <input type=${event.target.type}>.`,
            event.target
          );
          break;
      }
    }
  }
);

        </script>
    </head>
    <body>
        <dialog aria-labelledby="site-settings-title" id="site-settings-dialog">
            <h1 id="site-settings-title">Site settings</h1>
            <form method="dialog">
                <input-persist>
                    <label for="motion-toggle">Enable motion</label>
                    <input type="checkbox" id="motion-toggle" data-persist-key="motion-toggle">
                    <fieldset>
                        <legend>Color scheme</legend>
                        <label for="auto-color-scheme">Auto</label>
                        <input type="radio" name="color-scheme" id="auto-color-scheme" data-persist-key="auto-color-scheme"
                            checked>
                        <label for="light-color-scheme">Light</label>
                        <input type="radio" name="color-scheme" id="light-color-scheme" data-persist-key="light-color-scheme">
                        <label for="dark-color-scheme">Dark</label>
                        <input type="radio" name="color-scheme" id="dark-color-scheme" data-persist-key="dark-color-scheme">
                    </fieldset>
                </input-persist>
                <button type="submit">Close</button>
            </form>
        </dialog>
        
<style>
    header {
        position: relative;
        text-align: center;
    }

    header a {
        display: inline-block;
        height: 6rem;
        width: 6rem;
    }

    header a img {
        border-radius: 100%;
        transition: border-width .1s;
    }

    header a:hover img,
    header a:focus img {
        border: .3rem solid var(--home-link-focus-color);
    }

    .site-settings-button {
        position: absolute;
        right: 0;
    }
</style>
<header>
    <a href="/">
        <img src="/img/logo-250px.jpg" title="Home">
    </a>
    <button class="site-settings-button js-only" onclick="document.getElementById('site-settings-dialog').showModal()">
        Open site settings
    </button>
</header>

<style>
    h1 {
        margin-block-start: 0;
    }
</style>
<a href="/blog/">&larr; Blog</a>
<article>
    <h1>Code reviews are overloaded</h1>
    <i>January 7, 2023</i>
    <h2>Code reviews are effective</h2>
<p><strong>Code reviews are effective for uncovering bugs.</strong> We have multiple large studies backing this claim, estimating that the bug-detection rate of code reviews is in the ballpark of 50%. This is better evidence than we have for most software development practices. From <a href="https://en.wikipedia.org/wiki/Code_review#Efficiency_and_effectiveness_of_reviews">the Wikipedia article on code review</a>:</p>
<blockquote>
<p>Capers Jones' ongoing analysis of over 12,000 software development projects showed that the latent defect discovery rate of formal inspection is in the 60-65% range. For informal inspection, the figure is less than 50%. The latent defect discovery rate for most forms of testing is about 30%. A code review case study published in the book Best Kept Secrets of Peer Code Review found that lightweight reviews can uncover as many bugs as formal reviews, but were faster and more cost-effective in contradiction to the study done by Capers Jones.</p>
</blockquote>
<p>In addition to their primary value in discovering bugs, they can also be used to assess and improve many other aspects of the code. Design, readability, maintainability, code quality, test quality and coverage, consistency with project style guidelines and documentation are all areas where reviewers can find issues and suggest improvements. The act of reviewing and giving feedback can even help transfer knowledge between developers and be a tool for mentoring and learning.</p>
<p>On account of these benefits, code reviews have become wildly popular, and most software projects mandate that all changes must be approved by one or more reviewers. This virtually always means a <em>pull request based workflow</em>, where developers branch out from mainline, make some changes, then open a pull request that requires approval from a reviewer to merge back into mainline. At time of writing, this is the predominant way of working in our industry.</p>
<h2>Branching causes problems</h2>
<p>In projects using pull requests, the most popular strategy for branching is <em>feature branching</em>, creating a branch for a single feature and opening a pull request when the feature is complete. This is a convenient and intuitive way of organizing changes. However, these feature branches tend to be long-lived (on the order of days or weeks), and long-lived branches cause some serious issues.</p>
<p>In part four of Thierry de Pauw's article series <a href="https://thinkinglabs.io/articles/2021/04/26/on-the-evilness-of-feature-branching.html">On the Evilness of Feature Branching</a>, he goes into <a href="https://thinkinglabs.io/articles/2022/05/30/on-the-evilness-of-feature-branching-the-problems.html">the problems</a> of feature branching. The article is worth reading in full, but to summarize some of its points:</p>
<ul>
<li><strong>It delays feedback</strong> on how well changes integrate with other team members' work and how it runs in production.</li>
<li><strong>It causes rework</strong> through merge conflicts.</li>
<li><strong>It discourages refactoring</strong> as they have a high risk of causing merge conflicts.</li>
<li><strong>It introduces batch work and inventory</strong>, trapping valuable work in the system and worsening the throughput, quality, stability and lead time of changes.</li>
<li><strong>It increases risks</strong> by batching changes into large sets which are more likely to break, and harder to find the cause of when they do.</li>
</ul>
<p>Key to these issues is that they are more frequent and more severe the longer the branches live and the larger the changes are. Conversely, shorter-lived branches and smaller changes cause less issues. We can nearly eliminate the branching issues by pushing this all the way to <a href="https://martinfowler.com/articles/branching-patterns.html#continuous-integration">continuous integration</a>, where everyone's work is merged into mainline every day, potentially even multiple times an hour.</p>
<p>Code reviews make this infeasible for most software teams.</p>
<h2>Mandatory code reviews encourage long-lived branches</h2>
<p>When merging your work requires another developer to review and approve it, merging <em>will</em> happen less frequently, and pull requests <em>will not</em> shrink beyond a certain size. Dragan Stepanović explains this best in his article <a href="https://www.infoq.com/articles/co-creation-patterns-software-development/">From Async Code Reviews to Co-Creation Patterns</a>.</p>
<p>In short, code reviews introduce long wait times to the integration process. First, after a pull request is opened, the author waits for a review. Then, if the reviewer discovers any issues they think the author should handle, the reviewer waits for the author to respond to the feedback. This cycle repeats some number of times until the reviewer is satisfied and approves the pull request.</p>
<p>These wait times encourage developers to start new work in the meanwhile (increasing work-in-progress), and to batch their changes into larger pull requests. This, again, makes each review take longer, making it harder for developers to find time to review them, and increasing the odds of multiple rounds of review - increasing wait times even more! This vicious cycle results in pull requests often taking multiple days before they are able to be merged.</p>
<p>If a team still tries to make a push for continuous integration in this environment, they are fighting against the stream. The more frequently team members try to integrate, the more often they have to interrupt each other to review and respond to reviews. Developer attention bounces between multiple tasks, flow efficiency (time spent <em>working</em> to time spent <em>waiting</em>) plummets, and productivity drops. Every team will hit a point where the pain of this is too high and will stop integrating their changes any more frequently - typically stopping well short of continuous integration.</p>
<h2>Code reviews are hard to replace</h2>
<p>Many developers who recognize these problems assert that this kind of code review is a net negative and should be done away with altogether. Dave Farley, co-author of <em>Continuous Delivery</em>, insists that <a href="https://www.davefarley.net/?p=247">you are better off not branching at all</a>:</p>
<blockquote>
<ul>
<li>Don't Branch!</li>
<li>Don't Branch!</li>
<li>Don't Branch!</li>
</ul>
</blockquote>
<p>Instead of doing after-the-fact code review, he and others recommend that you support the quality of your software through other practices. The top recommendations are pair programming and mob/ensemble programming, which function as a sort of continuous code review while boosting the flow of work and knowledge sharing within your team. Test-driven development and a &quot;<em><a href="https://www.jamesshore.com/v2/books/aoad2/no_bugs">No Bugs</a></em>&quot;, root-cause eliminating attitude help reduce bug rates even further. By employing these practices, you may achieve better results than relying on code reviews. And I <em>want</em> to believe this.</p>
<p>However, in teams that frequently catch serious errors in code review, <strong>this is hard to sell</strong>. Most developers do not use these alternative practices, and asking people to change the way they work and spend time practicing new skills is a big ask for most teams. Without these changes, slashing code review will in all likelihood lead to more defects being pushed to mainline and escaping to production. Software teams have very reasonable motives for not wanting to do this.</p>
<p>This leaves me conflicted. I cannot in good conscience say that most teams should drop mandatory code reviews and that this will not cause major issues. Yet, I am thoroughly convinced that continuous integration <em>is</em> a better way of working.</p>
<p>Trapped in the middle, I am here to suggest a compromise: <strong>Code reviews should be reduced to their bare essentials.</strong></p>
<h2>Code reviews hurt more the more they try to do</h2>
<p>Here is my line of reasoning:</p>
<ol>
<li>When you look for more things in a code review, it becomes more demanding and time-consuming.</li>
<li>When code reviews get harder, developers will put them off, and wait times will grow.</li>
<li>When wait times grow, branches will live longer and pull requests will get larger, feeding the cycle and causing integration pain.</li>
</ol>
<p><strong>Conclusion:</strong> <em>The more things you look for in a code review, the more you will experience integration pain.</em> Conversely, if you reduce the number of things you look for in a code review, you will be able to integrate your work more frequently. If review gets easy enough, you may even find continuous integration feasible!</p>
<p>With this in mind, it becomes clear that we have made the review process very hard for ourselves. The most common thing to do is to include <em>every possible thing</em> worth having an opinion on in the scope of review. For instance, take <a href="https://google.github.io/eng-practices/review/reviewer/looking-for.html#summary">Google's sumary of what a reviewer should look for</a>:</p>
<blockquote>
<p>In doing a code review, you should make sure that:</p>
<ul>
<li>The code is well-designed.</li>
<li>The functionality is good for the users of the code.</li>
<li>Any UI changes are sensible and look good.</li>
<li>Any parallel programming is done safely.</li>
<li>The code isn’t more complex than it needs to be.</li>
<li>The developer isn’t implementing things they might need in the future but don’t know they need now.</li>
<li>Code has appropriate unit tests.</li>
<li>Tests are well-designed.</li>
<li>The developer used clear names for everything.</li>
<li>Comments are clear and useful, and mostly explain why instead of what.</li>
<li>Code is appropriately documented (generally in g3doc).</li>
<li>The code conforms to our style guides.</li>
</ul>
</blockquote>
<p><strong>This is a lot!</strong> A lot of things to pay attention to while reviewing, a lot to write feedback on, a lot of comments for the author to respond to. Several concerns like code quality and design (and without an authoritative style guide, code style and formatting) are highly subjective, and have a higher chance of causing disagreements, discussions, and multiple rounds of review - skyrocketing wait times.</p>
<p>Not only does this bucket list of concerns make review harder, but discussions of fuzzier, less critical issues drown out discussion of bugs. Quoting <a href="https://en.wikipedia.org/wiki/Code_review#Efficiency_and_effectiveness_of_reviews">the Wikipedia article</a> again:</p>
<blockquote>
<p>Empirical studies provided evidence that up to 75% of code review defects affect software evolvability/maintainability rather than functionality [...] This also means that less than 15% of the issues discussed in code reviews are related to bugs.</p>
</blockquote>
<p>Despite our primary motivation for mandating code review being bug reduction, we spend the majority of our attention on other, less critical issues. Combining this diluted focus with its influence to make pull requests larger, it is likely that trying to improve more things with code review actually makes matters worse.</p>
<h2>Limit your code reviews to the most important concerns</h2>
<p>Since mandatory code reviews cause more issues the more concerns they look for, they should be stripped down to the bare minimum of concerns that must be improved before merge. This will reduce the costs of review while improving its effectiveness for the concerns you do look for. What this bare minimum set is may vary from project to project, and you are free to decide what this is for yourself.</p>
<p><strong>Personally, I am convinced that you should cut any concern from your list that is not externally visible and can be improved later.</strong> This includes:</p>
<ul>
<li>Formatting and code style</li>
<li>Code quality and internal design details</li>
<li>Comments and documentation</li>
<li>Test coverage and quality</li>
</ul>
<p>All of these things are (more or less) valuable, and we want to do them well. However, <strong>none of them are externally visible</strong>, meaning it does not matter to our users if we merge and deploy them to production. Additionally, <strong>all of them can be improved later</strong>, and frequent low-friction integration makes it <em>easier</em> to make such improvements. Including them in review would harm integration frequency, which makes it harder to improve the quality of our codebase when we discover these issues while working.</p>
<p>If a developer opens pull requests that aren't up to snuff on any of these points, you have a couple of alternatives instead of checking it during review:</p>
<ol>
<li><strong>Talk to the developer about it.</strong> Make sure you agree to a common set of standards, and that they have the environment and resources to learn how to fulfill them. This is a longer term solution that will save you frustration in the long run.</li>
<li><strong>Fix it yourself.</strong> If you see room for improvement beyond your team's common set of standards, do it yourself instead of asking the author to do it. It is more effective and efficient, and it contributes to your team's sense of collective code ownership - you all have the right and responsibility to make improvements when you see them. And, since this change is to an issue that should be ignored by reviewers, it should be quick and easy to approve and merge back into mainline.</li>
</ol>
<p>Conversely, changes that are externally visible, or cannot be improved later, are more worth reviewing:</p>
<ul>
<li><strong>Bugs and security issues.</strong> We should ideally never introduce any of these, and we want to minimize the chance of any of them escaping to production.</li>
<li><strong>Design decisions that are hard to undo.</strong> This includes both external API designs (which are very hard to change once they are public), user interface designs, and any changes to functionality. The cost of getting these wrong is high, so it is worth spending extra effort getting them right.</li>
</ul>
<p>By limiting your review scope to these core concerns, you minimize the cost of mandating code reviews, while maintaining quality control on the issues you care the most about.</p>
<p><em>(Limiting and focusing the objective of code review like this also makes it easier to see when code reviews become obsolete - when bug rates drop to acceptable levels pre-review, and when you discuss and refine your irreversible design decisions outside of review. It is very easy to imagine high-performing teams working like this.)</em></p>
<h2>This is a suggested experiment</h2>
<p>While this strategy of cutting the scope of review makes a lot of sense to me, I cannot predict how it will play out for you, in your team, in your circumstances. I do not know to what degree it will make reviews easier and reduce integration pain, and I do not know what unexpected side effects it will have.</p>
<p>What I do believe is that this experiment is low risk, it is not very disruptive, and the potential rewards are great enough that <strong>you should try it out</strong>. Talk it out with your team, find a scope of review to try, trial it for a week or two, then reflect on how it went. If you do not like the results, you can always go back to your old way of working afterwards.</p>
<p><strong>If you try this, or have already tried it, please message me to share your experience!</strong> Contact me on Mastodon at <a href="https://hachyderm.io/@cvennevik">@cvennevik@hachyderm.io</a> (so I can share it further, if you like!), or email me at <a href="mailto:cvennevik@gmail.com">cvennevik@gmail.com</a>.</p>
<p><em>Edit, April 14th 2023: <a href="https://www.cvennevik.no/blog/oops-i-made-code-review-painful/">I wrote a post describing my experience following this idea.</a></em></p>

</article>
    </body>
</html>