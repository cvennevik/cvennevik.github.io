<!DOCTYPE html>
<html lang="en">
    <head>
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="color-scheme" content="dark light">
        <title>Crystal Spire #8: Facing our enemies - Cecilie Vennevik</title>
        <link rel="icon" type="image/jpg" href="/img/logo-32px.jpg" sizes="32x32">
        <link rel="icon" type="image/jpg" href="/img/logo-48px.jpg" sizes="48x48">
        <link rel="icon" type="image/jpg" href="/img/logo-64px.jpg" sizes="64x64">
        <meta name="author" content="Cecilie Vennevik">
        <link rel="alternate" title="Cecilie Vennevik's blog" href="/blog/rss.xml" type="application/rss+xml">
        <link rel="alternate" title="Cecilie Vennevik's blog" href="/blog/atom.xml" type="application/atom+xml">
        <style>
            *,
*::after,
*::before {
	box-sizing: border-box;
}

:root {
	--codeblock-color: #eee;
	--codeblock-background-color: #2b2b2b;
	--home-link-focus-color: #89cff0;

	--background-color: #f0f9fd;
	--foreground-color: rgba(255, 255, 255, 30%);
	--border-color: rgba(0, 0, 0, 10%);
	--text-color: #212;
	--code-background-color: rgba(0, 0, 0, 10%);
	--link-color: #086391;
	--link-focus-color: #89cff0;
	--header-background-color: #89cff0;
	--header-background-border-color: #086391;
	--header-link-color: #086391;
	--header-link-focus-color: #f0f9fd;
}

@media (prefers-color-scheme: dark) {
	:root {
		--background-color: #222;
		--foreground-color: #444;
		--border-color: rgba(255, 255, 255, 10%);
		--text-color: #fff;
		--code-background-color: #444;
		--link-color: #89cff0;
		--link-focus-color: #b8e2f6;
		--header-background-color: #086391;
		--header-background-border-color: #034c70;
		--header-link-color: #89cff0;
		--header-link-focus-color: #f0f9fd;
	}
}

html {
	background-color: var(--background-color);
	color: var(--text-color);
	font-family: 'Helvetica Neue', 'Arial Nova', Helvetica, Arial, sans-serif;
	height: 100%;
	line-height: 1.5;
}

body {
	margin: 0;
	padding: 0;
}

body > header {
	--link-color: var(--header-link-color);
	--link-focus-color: var(--header-link-focus-color);
	background-color: var(--header-background-color);
	border-bottom: .25rem solid var(--header-background-border-color);
}

.navbar {
	align-items: center;
	box-sizing: content-box;
	display: flex;
	gap: 1rem;
	margin: auto;
	max-width: 50rem;
	min-height: 3rem;
	padding: .5rem 1rem;
}

.navbar img {
	border-radius: 100%;
	display: inline-block;
	height: 2rem;
	width: 2rem;
}

.navbar nav {
	flex-grow: 1;
}

.crumbs {
	align-items: center;
	display: flex;
	gap: .5rem;
	list-style: none;
	margin: 0;
	padding: 0;
}

.crumbs li {
	display: flex;
	gap: .5rem;
}

main {
	margin: 0 auto;
	max-width: 50rem;
	padding: 1rem;
}

h1 { font-size: 2.5rem; }
h2 { font-size: 2rem; }
h3 { font-size: 1.75rem; }
h4 { font-size: 1.5rem; }
h5 { font-size: 1.3rem; }
h6 { font-size: 1.2rem; }

h1, h2, h3, h4, h5, h6 {
	font-weight: bold;
	line-height: 1.1;
	margin-block-start: 1em;
	margin-block-end: 0;
}

h1 {
	margin-block-start: 0;
}

a {
	color: var(--link-color);
	transition: color .1s;
}

a:focus,
a:hover {
	color: var(--link-focus-color);
}

blockquote {
	border-left: .3rem solid var(--border-color);
	margin: 1rem 0;
	padding: 0 1rem;
}

:not(pre) > code {
	background-color: var(--code-background-color);
}

pre {
	background-color: var(--codeblock-background-color);
	border-radius: 0.5em;
	color: var(--codeblock-color);
	font-family: ui-monospace, 'Cascadia Code', 'Source Code Pro', Menlo, Consolas, 'DejaVu Sans Mono', monospace;
	hyphens: none;
	line-height: 1.4;
	padding: 1em;
	overflow: auto;
	tab-size: 4;
	white-space: pre-wrap;
}

img {
	max-width: 100%;
}

figure {
	display: flex;
	flex-direction: column;
	justify-content: center;
	margin: 1.3rem 0;
}

figure img {
	border: .3rem solid var(--border-color);
	border-radius: .3rem;
}

figcaption {
	font-style: italic;
	margin-top: .5em;
	text-align: center;
}

        </style>
        <script>
            // <input-persist> observes all contained input elements with a [data-persist-key] attribute.
// When the user changes the value of an input element, it saves that value to local storage.
// The [data-persist-key] attribute specifies the storage key.
// When an input element first loads - or is placed - inside <input-parsist>, its value is set to the stored value.
//
// <input-persist> supports the following elements:
// - <input type="checkbox">
// - <input type="radio">
customElements.define(
  "input-persist",
  class extends HTMLElement {
    connectedCallback() {
      const observer = new MutationObserver((mutations) => {
        mutations.forEach((mutation) => {
          mutation.removedNodes.forEach((node) => {
            node.removeEventListener("input", this);
          });
          mutation.addedNodes.forEach((node) => {
            if (node.nodeName == "INPUT") {
              node.addEventListener("input", this);
              const persistKey = node.dataset.persistKey;
              if (!persistKey) return;

              const savedValue = localStorage.getItem(persistKey);
              if (savedValue) {
                switch (node.type) {
                  case "checkbox":
                  case "radio":
                    node.checked = savedValue === "checked";
                    break;
                  default:
                    console.warn(
                      `input-persist: cannot persist unsupported element <input type=${node.type}>.`,
                      node
                    );
                    break;
                }
              }
            }
          });
        });
      });
      observer.observe(this, { childList: true, subtree: true });
    }

    handleEvent(event) {
      const persistKey = event.target.dataset.persistKey;
      if (!persistKey) return;

      switch (event.target.type) {
        case "checkbox":
          localStorage.setItem(
            persistKey,
            event.target.checked ? "checked" : "unchecked"
          );
          break;
        case "radio":
          const radioName = event.target.getAttribute("name");
          this.querySelectorAll(`input[name=${radioName}]`).forEach((radio) => {
            if (radio.dataset.persistKey) {
              localStorage.setItem(
                radio.dataset.persistKey,
                radio === event.target ? "checked" : "unchecked"
              );
            }
          });
          break;
        default:
          console.warn(
            `input-persist: cannot persist unsupported element <input type=${event.target.type}>.`,
            event.target
          );
          break;
      }
    }
  }
);
        </script>
    </head>
    <body>
        <header>
            <div class="navbar">
                
                <img src="/img/logo-250px.jpg" alt="Seal-in-a-glass logo">
                <nav aria-labelledby="navbar-label">
                    <span id="navbar-label">You are here.</span>
                    <ol class="crumbs">
                        
<li>
    <a href="/">Home</a>
    <span aria-hidden="true">/</span>
</li>
<li>
    <a href="/blog/">Blog</a>
    <span aria-hidden="true">/</span>
</li>
<li>Post</li>

                    </ol>
                </nav>
                
            </div>
        </header>
        <main>
            
<style>
    h1 {
        margin-block-start: 0;
    }
</style>
<article>
    <h1>Crystal Spire #8: Facing our enemies</h1>
    <i>February 1, 2025</i>
    <p>Happy new year! Parenting is going great. We just moved my home computer out of the living room and into my office, so now, for the first time in a long while, I have comfortable spot to code in. The baby is napping longer and more consistently, too, so let's use a little of that time to chip away at this again. Dust off those programming muscles.</p>
<p>There's still a fair bit of game state to make dynamic, namely the enemy. This fight has one enemy, but there can be several enemies, and each of them has:</p>
<ul>
<li>A name</li>
<li>HP</li>
<li>Armor</li>
<li>Buffs and debuffs</li>
<li>Its next move</li>
<li>A history of previous moves
<ul>
<li>This affects which move it may choose next</li>
</ul>
</li>
</ul>
<p>All of these need to be made into a variable (an array of &quot;enemy&quot; objects, most likely), and then we need a way to encode it into the query string. Let's save the tricky bit for later, and hard-code the data first:</p>
<pre><code class="language-js">let enemies = [
    {
        name: 'Jaw Worm',
        hp: 42,
        maxHp: 42,
        nextMove: 'Chomp'
    }
];
</code></pre>
<p>Then use the data in our templating:</p>
<pre><code class="language-js">&lt;h2&gt;Enemies&lt;/h2&gt;
${enemies.map(enemy =&gt; `
    &lt;h3&gt;${enemy.name}&lt;/h3&gt;
    &lt;p&gt;HP: ${enemy.hp}/${enemy.maxHp}&lt;/p&gt;
    &lt;p&gt;Next move: ${enemy.nextMove}&lt;/p&gt;
`).join('')}
</code></pre>
<p>Looks okay, but we're missing the move description now. I don't think this is the long-term solution, but let's make a dictionary of descriptions, just like we did for relics, to keep it out of the dynamic state.</p>
<pre><code class="language-js">let moveDescriptions = { 'Chomp': 'Deal 11 damage' };
// ...
&lt;p&gt;Next move: ${enemy.nextMove} (${moveDescriptions[enemy.nextMove]})&lt;/p&gt;
</code></pre>
<p>Oh yeah, this is going to be a problem very soon. The Jaw Worm deals more than 11 damage when it gains strength, so a static dictionary of descriptions is not going to cut it. That's a future problem though, and an interesting one at that. Future us can spend a whole session figuring that out.</p>
<p>Commit: &quot;Render enemies based on 'enemies' array&quot;.</p>
<p>Now the difficult part. We need to encode this data, this array of objects, into our query string. We've only handled simple values and lists of simple values to this point. We need a different method for handling a list of objects.</p>
<p>Starting with the simplest thing that will possibly work... Can we just parse it as JSON?</p>
<pre><code class="language-js">let enemies = JSON.parse(queryParams.get('enemies')) ?? [
    {
        name: 'Jaw Worm',
        hp: 42,
        maxHp: 42,
        nextMove: 'Chomp'
    }
];
</code></pre>
<p>Well, the fallback value works correctly when &quot;enemies&quot; is missing from the query string.</p>
<p>Now what if we add <code>?enemies=[]</code> to it? Aha! No enemies!</p>
<p>Then what about <code>?enemies=[{&quot;name&quot;: &quot;Jaw Worm&quot;, &quot;hp&quot;: 30, &quot;maxHp&quot;: 42, &quot;nextMove&quot;: &quot;Chomp&quot;}]</code>? Goodness, me, it works. Didn't even need to deal with URI encoding.</p>
<p>Let's add this query parameter to our sketched action links, so we can finally see our attacks dealing damage:</p>
<pre><code class="language-js">&lt;a href=&quot;?maxhp=80&amp;maxenergy=3&amp;relics=Burning%20Blood&amp;hp=80&amp;energy=1&amp;hand=Defend,Defend,Defend,Strike&amp;draw=Defend,Strike,Strike,Strike,Strike&amp;discard=Bash&amp;enemies=%5B%7B%22name%22%3A%20%22Jaw%20Worm%22%2C%20%22hp%22%3A%2034%2C%20%22maxHp%22%3A%2042%2C%20%22nextMove%22%3A%20%22Chomp%22%7D%5D&quot;&gt;
    Play Bash on Jaw Worm
&lt;/a&gt;
// ...
&lt;a href=&quot;?maxhp=80&amp;maxenergy=3&amp;relics=Burning%20Blood&amp;hp=80&amp;energy=2&amp;hand=Bash,Defend,Defend,Defend&amp;draw=Defend,Strike,Strike,Strike,Strike&amp;discard=Strike&amp;enemies=%5B%7B%22name%22%3A%20%22Jaw%20Worm%22%2C%20%22hp%22%3A%2036%2C%20%22maxHp%22%3A%2042%2C%20%22nextMove%22%3A%20%22Chomp%22%7D%5D&quot;&gt;
    Play Strike on Jaw Worm
&lt;/a&gt;
</code></pre>
<p>Had to URI-encode the array to fit it into the HTML, but the JSON parsing still works. And these links work! We're dealing damage!</p>
<p>Commit: &quot;Set 'enemies' array based on query parameter&quot;.</p>
<p>All this URL parsing is very space-inefficient, but I don't think it the URL will grow long enough to cause issues while we're only running the Jaw Worm fight. It's good enough for now.</p>
<p>Hm, I keep excusing design flaws that I imagine we will fix later. I wonder if that's necessary.</p>
<p>Anyway. Next time: enemy armor, buffs, and debuffs.</p>
<hr>
<p><em><a href="https://codeberg.org/cvennevik/crystal-spire/src/commit/fe7c1d1bcd8ecaa20f4ef01108a4854c0cb896b9">Last commit: Set 'enemies' array based on query parameter</a></em></p>

</article>

        </main>
    </body>
</html>