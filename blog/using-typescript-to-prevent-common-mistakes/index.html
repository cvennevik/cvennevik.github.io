<!DOCTYPE html>
<html lang="en" class="js-disabled">
    <head>
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <title>Using TypeScript to prevent common mistakes - Cecilie Vennevik</title>
        <link rel="icon" type="image/jpg" href="/img/logo-32px.jpg" sizes="32x32">
        <link rel="icon" type="image/jpg" href="/img/logo-48px.jpg" sizes="48x48">
        <link rel="icon" type="image/jpg" href="/img/logo-64px.jpg" sizes="64x64">
        <meta name="author" content="Cecilie Vennevik">
        <link rel="alternate" title="Cecilie Vennevik's blog" href="/blog/rss.xml" type="application/rss+xml">
        <link rel="alternate" title="Cecilie Vennevik's blog" href="/blog/atom.xml" type="application/atom+xml">
        <style>
            *,
*::after,
*::before {
	box-sizing: border-box;
}

:root {
	--codeblock-color: #eee;
	--codeblock-background-color: #2b2b2b;
	--home-link-focus-color: #89cff0;

	--background-color: #f0f9fd;
	--foreground-color: rgba(255, 255, 255, 30%);
	--border-color: rgba(0, 0, 0, 10%);
	--text-color: #212;
	--code-background-color: rgba(0, 0, 0, 10%);
	--link-color: #086391;
	--link-focus-color: #89cff0;
}

@media (prefers-color-scheme: dark) {
	:root {
		--background-color: #222;
		--foreground-color: #444;
		--border-color: rgba(255, 255, 255, 10%);
		--text-color: #fff;
		--code-background-color: #444;
		--link-color: #89cff0;
		--link-focus-color: #b8e2f6;
	}
}

:root:has(#light-color-scheme:checked) {
	--background-color: #f0f9fd;
	--foreground-color: rgba(255, 255, 255, 30%);
	--border-color: rgba(0, 0, 0, 10%);
	--text-color: #212;
	--code-background-color: rgba(0, 0, 0, 10%);
	--link-color: #086391;
	--link-focus-color: #89cff0;
}

:root:has(#dark-color-scheme:checked) {
	--background-color: #222;
	--foreground-color: #444;
	--border-color: rgba(255, 255, 255, 10%);
	--text-color: #fff;
	--code-background-color: #444;
	--link-color: #89cff0;
	--link-focus-color: #b8e2f6;
}

html {
	background-color: var(--background-color);
	color: var(--text-color);
	font-family: 'Helvetica Neue', 'Arial Nova', Helvetica, Arial, sans-serif;
	height: 100%;
	line-height: 1.5;
}

body {
	margin: 0 auto;
	max-width: 50rem;
	padding: 1rem;
	padding-bottom: 2rem;
}

h1,
h2,
h3,
h4,
h5,
h6 {
	font-weight: bold;
	line-height: 1.1;
	margin-block-start: 1em;
	margin-block-end: 0;
}

h1 {
	font-size: 2.5rem;
}

h2 {
	font-size: 2rem;
}

h3 {
	font-size: 1.75rem;
}

h4 {
	font-size: 1.5rem;
}

h5 {
	font-size: 1.3rem;
}

h6 {
	font-size: 1.2rem;
}

a {
	color: var(--link-color);
	transition: color .1s;
}

a:focus,
a:hover {
	color: var(--link-focus-color);
}

blockquote {
	border-left: .3rem solid var(--border-color);
	margin: 1rem 0;
	padding: 0 1rem;
}

:not(pre)>code {
	background-color: var(--code-background-color);
}

pre {
	background-color: var(--codeblock-background-color);
	border-radius: 0.5em;
	color: var(--codeblock-color);
	font-family: ui-monospace, 'Cascadia Code', 'Source Code Pro', Menlo, Consolas, 'DejaVu Sans Mono', monospace;
	hyphens: none;
	line-height: 1.4;
	padding: 1em;
	overflow: auto;
	tab-size: 4;
	white-space: pre-wrap;
}

img {
	max-width: 100%;
}

figure {
	display: flex;
	flex-direction: column;
	justify-content: center;
	margin: 1.3rem 0;
}

figure img {
	border: .3rem solid var(--border-color);
	border-radius: .3rem;
}

figcaption {
	font-style: italic;
	margin-top: .5em;
	text-align: center;
}

.js-disabled .js-only {
	display: none;
}
        </style>
        <script>
            // <input-persist> observes all contained input elements with a [data-persist-key] attribute.
// When the user changes the value of an input element, it saves that value to local storage.
// The [data-persist-key] attribute specifies the storage key.
// When an input element first loads - or is placed - inside <input-parsist>, its value is set to the stored value.
//
// <input-persist> supports the following elements:
// - <input type="checkbox">
// - <input type="radio">
customElements.define(
  "input-persist",
  class extends HTMLElement {
    connectedCallback() {
      const observer = new MutationObserver((mutations) => {
        mutations.forEach((mutation) => {
          mutation.removedNodes.forEach((node) => {
            node.removeEventListener("input", this);
          });
          mutation.addedNodes.forEach((node) => {
            if (node.nodeName == "INPUT") {
              node.addEventListener("input", this);
              const persistKey = node.dataset.persistKey;
              if (!persistKey) return;

              const savedValue = localStorage.getItem(persistKey);
              if (savedValue) {
                switch (node.type) {
                  case "checkbox":
                  case "radio":
                    node.checked = savedValue === "checked";
                    break;
                  default:
                    console.warn(
                      `input-persist: cannot persist unsupported element <input type=${node.type}>.`,
                      node
                    );
                    break;
                }
              }
            }
          });
        });
      });
      observer.observe(this, { childList: true, subtree: true });
    }

    handleEvent(event) {
      const persistKey = event.target.dataset.persistKey;
      if (!persistKey) return;

      switch (event.target.type) {
        case "checkbox":
          localStorage.setItem(
            persistKey,
            event.target.checked ? "checked" : "unchecked"
          );
          break;
        case "radio":
          const radioName = event.target.getAttribute("name");
          this.querySelectorAll(`input[name=${radioName}]`).forEach((radio) => {
            if (radio.dataset.persistKey) {
              localStorage.setItem(
                radio.dataset.persistKey,
                radio === event.target ? "checked" : "unchecked"
              );
            }
          });
          break;
        default:
          console.warn(
            `input-persist: cannot persist unsupported element <input type=${event.target.type}>.`,
            event.target
          );
          break;
      }
    }
  }
);

        </script>
        <script>
            document.documentElement.classList.remove('js-disabled');
        </script>
    </head>
    <body>
        <dialog aria-labelledby="site-settings-title" id="site-settings-dialog">
            <h1 id="site-settings-title">Site settings</h1>
            <form method="dialog">
                <input-persist>
                    <label for="motion-toggle">Enable motion</label>
                    <input type="checkbox" id="motion-toggle" data-persist-key="motion-toggle">
                    <fieldset>
                        <legend>Color scheme</legend>
                        <label for="auto-color-scheme">Auto</label>
                        <input type="radio" name="color-scheme" id="auto-color-scheme" data-persist-key="auto-color-scheme"
                            checked>
                        <label for="light-color-scheme">Light</label>
                        <input type="radio" name="color-scheme" id="light-color-scheme" data-persist-key="light-color-scheme">
                        <label for="dark-color-scheme">Dark</label>
                        <input type="radio" name="color-scheme" id="dark-color-scheme" data-persist-key="dark-color-scheme">
                    </fieldset>
                </input-persist>
                <button type="submit">Close</button>
            </form>
        </dialog>
        
<style>
    header {
        position: relative;
        text-align: center;
    }

    header a {
        display: inline-block;
        height: 6rem;
        width: 6rem;
    }

    header a img {
        border-radius: 100%;
        transition: border-width .1s;
    }

    header a:hover img,
    header a:focus img {
        border: .3rem solid var(--home-link-focus-color);
    }

    .site-settings-button {
        position: absolute;
        right: 0;
    }
</style>
<header>
    <a href="/">
        <img src="/img/logo-250px.jpg" title="Home">
    </a>
    <button class="site-settings-button js-only" onclick="document.getElementById('site-settings-dialog').showModal()">
        Open site settings
    </button>
</header>

<style>
    h1 {
        margin-block-start: 0;
    }
</style>
<a href="/blog/">&larr; Blog</a>
<article>
    <h1>Using TypeScript to prevent common mistakes</h1>
    <i>January 17, 2023</i>
    <p>I have been struggling to write an article about type systems for about a week now. The ideas and angles I want to take kept changing between each writing session, preventing me from ever completing a single coherent article.</p>
<p>After venting about this on Mastodon, another user asked me what I thought about static types. They were mostly experienced with dynamically typed languages, and prefer the flexibility they offer.</p>
<p>It turns out this question was all I needed to focus and get my writing back on track - you may take this blog post as my longform answer.</p>
<p>In short: I think static types are a useful tool to prevent us from making very common mistakes. Like, really common. Like &quot;half of the bugs I investigate in JavaScript applications are caused by this&quot; common.</p>
<p>Here's a few examples to illustrate the types of mistakes I'm talking about, and how adding static types with TypeScript helps prevent them.</p>
<h2>Mistake #1: Accessing undefined property names</h2>
<p>Say we are working with an object containing user profile data, and we want to send an email to that user. To do this, we access the user's email address via <code>user.emailAddress</code> and pass it to <code>sendEmail</code>.</p>
<pre><code class="language-ts">function sendEmailToUser (user) {
    sendEmail(user.emailAddress);
}
</code></pre>
<p>But what if we are mistaken? What if the <code>user</code> object's property is actually named <code>emailaddress</code>, or <code>address</code>, or <code>username</code>, or - gasp - it does not actually have a property for email address at all? Well, then this code will instead attempt to send an email to <code>undefined</code>. That's no good.</p>
<p>To check for this potential issue, let us say we found the <code>UserProfile</code> type that describes the user data we expect, and specify that <code>user</code> is of type <code>UserProfile</code>.</p>
<pre><code class="language-ts">interface UserProfile {
    // ...
    contactInfo: {
        // ...
        emailAddress: string
    }
}

function sendEmailToUser (user: UserProfile) {
    sendEmail(user.emailAddress); // Causes a build error!
}
</code></pre>
<p>Oops! It turns out the <code>user.emailAddress</code> property does not exist. Now, because we are trying to access a property that does not exist on <code>UserProfile</code>, the TypeScript compiler produces an error.</p>
<p>The <code>UserProfile</code> type instead tells us that a <code>user.contactInfo.emailAddress</code> property exists. This is likely what we actually wanted to use, and replacing <code>user.emailAddress</code> with this will make the error go away.</p>
<h2>Mistake #2: Passing invalid data</h2>
<p>Say we are working with a map, and want to place an icon at the spot where the user's mouse pointer is:</p>
<pre><code class="language-ts">function getMousePosition () {
    // ...
}

function setIconPosition (position) {
    // ...
}

function placeIconAtMousePosition () {
    const mousePosition = getMousePosition();
    setIconPosition(mousePosition);
}
</code></pre>
<p>What can go wrong here? Well, we do not know the structure of the data <code>getMousePosition</code> returns, nor what <code>setIconPosition</code> accepts. Even if we already know we are working with longitude and latitude positions in the same coordinate system, the position could be represented as a <code>{ lon, lat }</code> object, or an <code>{ x, y }</code> object, or a <code>[lon, lat]</code> array (or even a <code>[lat, lon]</code> array!).</p>
<p>Without type annotations, this code looks perfectly valid, even if the data structures may be incompatible. Now, if we add the correct types to the functions using TypeScript, the incompatibility comes to light:</p>
<pre><code class="language-ts">function getMousePosition (): { lon: number, lat: number } {
    // ...
}

function setIconPosition (position: { x: number, y: number }) {
    // ...
}

function placeIconAtMousePosition () {
    const mousePosition = getMousePosition();
    setIconPosition(mousePosition); // Causes a build error!
}
</code></pre>
<p>With the function types specified, TypeScript reports that we made a mistake passing <code>mousePosition</code> directly into <code>setIconPosition</code>. Instead, we should convert the <code>{ lon, lat }</code> object to an <code>{ x, y }</code> object.</p>
<pre><code class="language-ts">function placeIconAtMousePosition () {
    const mousePosition = getMousePosition();
    setIconPosition({
        x: mousePosition.lon,
        y: mousePosition.lat
    });
}
</code></pre>
<h2>Mistake #3: Not handling undefined values</h2>
<p>The third common mistake TypeScript can prevent is the famed <em>&quot;billion dollar mistake&quot;</em>: <s>null</s> undefined values!</p>
<p>Let's reuse the map position code example and see what happens when we modify it. Say we change the implementation of <code>getMousePosition</code> so it returns <code>undefined</code> when the mouse is outside the map. TypeScript will not permit this since this does not match the return type of <code>getMousePosition</code>, so we change the return type so it can also be <code>undefined</code>:</p>
<pre><code class="language-ts">function getMousePosition (): { lon: number, lat: number } | undefined {
    // ...
}

function setIconPosition (position) {
    // ...
}

function placeIconAtMousePosition () {
    const mousePosition = getMousePosition();
    setIconPosition({
        x: mousePosition.lon, // Causes a build error!
        y: mousePosition.lat
    });
}
</code></pre>
<p>Oh no! This change actually breaks <code>placeIconAtMousePosition</code>, because it was written with the assumption that <code>getMousePosition</code> always returns a valid position. When it instead returns <code>undefined</code>, the code will throw a runtime error when trying to access <code>mousePosition.lon</code>.</p>
<p>If we were working with untyped JavaScript, this mistake may have managed to sneak in. Luckily, TypeScript caught this error for us. It refuses to compile until we have correctly handled the case where <code>mousePosition</code> is undefined. If we add a check for it, the error disappears:</p>
<pre><code class="language-ts">function placeIconAtMousePosition() {
    const mousePosition = getMousePosition();
    if (mousePosition === undefined) return;
    setIconPosition({
        x: mousePosition.lon,
        y: mousePosition.lat
    });
}
</code></pre>
<p>I like to set up development environments so it is easy to write correct code and hard to write incorrect code. Static types are only one of several tools I use for this, but they are one of my favorites. They tell us what we can and cannot do with our data, and they are effective for catching very common mistakes. Because of this, I find the overhead of opting into static typing with TypeScript well worth it.</p>

</article>
    </body>
</html>